main                        = _{ SOI ~ definition* ~ EOI }

definition                  = _{ struct_decl | function }

/// Statements
stmt                        = _{ (let_stmt | assign_stmt | function_call) ~ semicolon }

let_stmt                    = { "let" ~ ident ~ typespec ~ "=" ~ expr }
assign_stmt                 = { dereferenceable ~ "=" ~ expr }

dereferenceable             = _{ field_expr | array_index | ident }

/// Values and Types
ident                       = @{ XID_START ~ XID_CONTINUE* }
ty                          =  { ident | array_ty | tuple_ty }
typespec                    = _{ colon ~ ty }

literal                     = _{ decimal | integer | boolean | array | tuple }

/// Functions

// A code block is simply a sequence of statements with an optional expression at the end
code_block                  = _{ open_block ~ (definition | stmt)* ~ expr? ~ close_block }
function                    =  { "fn" ~ ident ~ function_args ~ function_return? ~ code_block }
function_args               = _{ open_paren ~ (function_arg ~ comma)* ~ function_arg? ~ close_paren }
function_arg                = _{ ident ~ typespec }
function_return             = _{ "->" ~ ty }

function_call               = _{ ident ~ open_paren ~ (expr ~ comma)* ~ expr? ~ close_paren }

/// Expressions
expr                        = _{ infix | inner_expr }

inner_expr                  = _{ array_index | accessible_expr }
// expressions which can be accessed via array indexing
accessible_expr             = _{ prefix | function_call | braced_expr | literal | code_block | struct_construct_expr | field_expr | ident }

braced_expr                 = _{ open_paren ~ expr ~ close_paren }
field_expr                  =  { ident ~ ("." ~ ident)+ } // x.y.z.w.etc

prefix                      =  { unary_operator ~ expr }
infix                       =  { inner_expr ~ (binary_operator ~ inner_expr)+ }

/// Arrays
array                       = _{ open_square ~ (expr ~ (comma ~ expr)*)? ~ close_square }
array_ty                    = _{ open_square ~ ty ~ semicolon ~ integer ~ close_square}
array_index                 = _{ accessible_expr ~ (open_square ~ expr ~ close_square)+ }

/// Tuples
tuple                       = _{ open_paren ~ (expr ~ comma)+ ~ expr? ~ close_paren }
tuple_ty                    = _{ open_paren ~ (ty   ~ comma)+ ~ ty?   ~ close_paren }

/// Structs
struct_field                =  { ident ~ colon ~ ty }
struct_fields               = _{ (struct_field ~ comma)* ~ struct_field? }
struct_decl                 =  { "struct" ~ ident ~ open_block ~ struct_fields ~ close_block }

struct_construct_field      =  { ident ~ colon ~ expr }
struct_construct_fields     = _{ (struct_construct_field ~ comma)* ~ struct_construct_field }
struct_construct_expr       =  { ident ~ open_block ~ struct_construct_fields ~ close_block }

/// Basic symbols
colon                       = { ":" }
semicolon                   = { ";" }
comma                       = { "," }
open_block                  = { "{" }
close_block                 = { "}" }
open_square                 = { "[" }
close_square                = { "]" }
open_paren                  = { "(" }
close_paren                 = { ")" }

/// Whitespace and Comments
WHITESPACE                  = _{ (" " | "\t" | "\r" | "\n")+ }
COMMENT                     = _{ comment_block | comment_line }
comment_block               = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line                = @{ "//" ~ (!("\r" | "\n") ~ ANY)* }

/// Numeric values
decimal                     = ${ signed_integer+ ~ ("." ~ integer+)? ~ (^"e" ~ signed_integer)? }

signed_integer              =  { "-"? ~ integer }
integer                     = ${ hexinteger | binaryinteger | octalinteger | decinteger }

decinteger                  = @{ ASCII_DIGIT+ }
binaryinteger               = @{ ^"0b" ~ ASCII_BIN_DIGIT+ }
hexinteger                  = @{ ^"0x" ~ ASCII_HEX_DIGIT+ }
octalinteger                = @{ ^"0o" ~ ASCII_OCT_DIGIT+ }

/// Operators
multiply                    =  { "*" }
divide                      =  { "/" }
modulus                     =  { "%" }
plus                        =  { "+" }
minus                       =  { "-" }
shift_left                  =  { "<<" }
shift_right                 =  { ">>" }
less_than                   =  { "<" }
less_than_or_equal          =  { "<=" }
greater_than                =  { ">" }
greater_than_or_equal       =  { ">=" }
not_equal                   =  { "!=" }
equal                       =  { "==" }
logical_and                 =  { "&&" }
logical_or                  =  { "||" }
logical_not                 =  { "!" }
bitwise_and                 =  { "&" }
bitwise_or                  =  { "|" }
bitwise_xor                 =  { "^" }
assign                      =  { "=" }

unary_operator              = _{ plus | minus | logical_not }
binary_operator             = _{
                                 multiply | divide | modulus |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or |
                                 bitwise_and | bitwise_or | bitwise_xor
                               }


/// Boolean literal
boolean                     =  { boolean_true | boolean_false }
boolean_true                =  { "true" }
boolean_false               =  { "false" }
